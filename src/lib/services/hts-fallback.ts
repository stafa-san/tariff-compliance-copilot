/**
 * HTS Fallback Lookup â€” Server-side only
 *
 * Provides offline HTS code lookup when the live USITC API is unavailable.
 * Loads data from src/lib/data/hts-lookup.json (generated by scripts/sync-hts-data.ts).
 *
 * Data Provenance:
 *   Source:    USITC REST API (hts.usitc.gov/reststop/exportList)
 *   Format:   JSON, styles stripped
 *   Scope:    All chapters (01-99), entries with duty rates only
 *   Updated:  Run `pnpm run sync-hts` to refresh
 *   License:  Public domain (U.S. Government work)
 */

import { readFileSync, existsSync } from "fs";
import { join } from "path";

interface HTSEntry {
  code: string;
  description: string;
  general: string;
  special: string;
  other: string;
  units: string[];
  indent: number;
  chapter: string;
  heading: string;
  footnotes: string[];
}

interface HTSLookupData {
  metadata: {
    source: string;
    apiUrl: string;
    downloadedAt: string;
    totalRecords: number;
    entriesWithRates: number;
    version: string;
    note: string;
  };
  entries: HTSEntry[];
}

let cachedData: HTSLookupData | null = null;

function loadData(): HTSLookupData | null {
  if (cachedData) return cachedData;

  const dataPath = join(process.cwd(), "src", "lib", "data", "hts-lookup.json");
  if (!existsSync(dataPath)) {
    console.warn("[HTS Fallback] No local data file found at", dataPath);
    console.warn("[HTS Fallback] Run `pnpm run sync-hts` to download USITC data.");
    return null;
  }

  try {
    const raw = readFileSync(dataPath, "utf-8");
    cachedData = JSON.parse(raw);
    console.log(
      `[HTS Fallback] Loaded ${cachedData!.metadata.totalRecords} entries ` +
        `(downloaded: ${cachedData!.metadata.downloadedAt})`
    );
    return cachedData;
  } catch (err) {
    console.error("[HTS Fallback] Failed to load data:", err);
    return null;
  }
}

/**
 * Search the local HTS database by keyword or HTS code.
 * Mimics the USITC API response format for compatibility.
 */
export function searchLocalHTS(keyword: string): {
  source: "local_fallback";
  dataAge: string;
  resultCount: number;
  results: {
    htsCode: string;
    description: string;
    generalRate: string;
    specialRate: string;
    otherRate: string;
    indent: string;
    units: string[];
  }[];
} {
  const data = loadData();
  if (!data) {
    return { source: "local_fallback", dataAge: "unavailable", resultCount: 0, results: [] };
  }

  const normalizedKeyword = keyword.toLowerCase().replace(/\./g, "").trim();
  const isCodeSearch = /^\d{4,}/.test(normalizedKeyword);

  let matches: HTSEntry[];

  if (isCodeSearch) {
    // Code-based search: match by prefix
    const codePrefix = normalizedKeyword.replace(/\D/g, "");
    matches = data.entries.filter((e) => {
      const normalizedCode = e.code.replace(/\./g, "");
      return normalizedCode.startsWith(codePrefix);
    });
  } else {
    // Keyword search: match against description
    const keywords = normalizedKeyword.split(/\s+/);
    matches = data.entries.filter((e) => {
      const desc = e.description.toLowerCase();
      return keywords.every((kw) => desc.includes(kw));
    });
  }

  // Return top 15 results
  const results = matches.slice(0, 15).map((e) => ({
    htsCode: e.code,
    description: e.description,
    generalRate: e.general,
    specialRate: e.special,
    otherRate: e.other,
    indent: String(e.indent),
    units: e.units,
  }));

  return {
    source: "local_fallback",
    dataAge: data.metadata.downloadedAt,
    resultCount: matches.length,
    results,
  };
}

/**
 * Get metadata about the local HTS data (for provenance tracking).
 */
export function getLocalHTSMetadata(): HTSLookupData["metadata"] | null {
  const data = loadData();
  return data?.metadata ?? null;
}
